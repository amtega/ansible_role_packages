---
# Role default lower priority variables

# Dictionary with the operating system packages to manage for each distribution
# name/major release combination. The structure of the dict is the following:
#
# {
#   <distribution name 1>:
#     <distribution 1 major release 1>:
#       <package name 1>: <state (as expected by ansible package module)>
#       <package name 2>: <state>
#       <package name N>: <state>
#     <distribution 1 major release 2>:
#       <package name 1>: <state>
#       <package name 2>: <state>
#       <package name N>: <state>
#     <distribution 1 major release N>:
#       <package name 1>: <state>
#       <package name 2>: <state>
#       <package name N>: <state>
#
#   <distribution name 2>:
#     <distribution 2 major release 1>:
#       <package name 1>: <state>
#       <package name 2>: <state>
#       <package name N>: <state>
#     <distribution 2 major release 2>:
#       <package name 1>: <state>
#       <package name 2>: <state>
#       <package name N>: <state>
#     <distribution 2 major release N>:
#       <package name 1>: <state>
#       <package name 2>: <state>
#       <package name N>: <state>
# }
#
# In the previous dictionary you can replace distribion name/major release by
# the `all` keyword to apply that config to all distributions/releases.
#
# If the order of the packages is important, you can replace the dictionary
# structure for the packages by a list of dictionaries in this way:
# {
#   <distribution name 1>:
#     <distribution 1 major release 1>:
#       - <package name 1>: <state (as expected by ansible package module)>
#       - <package name 2>: <state>
#       - <package name N>: <state>
#    ...
# }
#
# If the name of the package needs to be generated by jinja, you can expand the
# list of dictionaries detailed before in this way:
# {
#   <distribution name 1>:
#     <distribution 1 major release 1>:
#       - name: <package name 1>
#         state: <state (as expected by ansible package module)>
#       - name: <package name2>
#         state: <state>
#       - name: <package name3>
#         state: <state>
#    ...
# }

packages_os: {}

# Dictionary with the python packages to manage for each distribution name/major
# release combination. The structure of the dict is the same that for the
# variable `packages_os`.
#
# This variable accepts also the following extra pip arguments for the python
# packages, with the same meaning that in ansible `pip` module:
#
# - `virtualenv`
# - `virtualenv_command`
# - `virtualenv_site_packages`
# - `extra_args`
#
# {
#   <distribution name 1>:
#     <distribution 1 major release 1>:
#       - name: <package name 1>
#         state: <state (as expected by ansible package module)>
#         virtualenv: <path>
#         virtualenv_command: <path>
#         virtualenv_site_packages: <path>
#         extra_args: <args>
#       - name: <package name2>
#         state: <state>
#         virtualenv: <path>
#         virtualenv_command: <path>
#         virtualenv_site_packages: <path>
#         extra_args: <args>
#       - name: <package name3>
#         state: <state>
#         virtualenv: <path>
#         virtualenv_command: <path>
#         virtualenv_site_packages: <path>
#         extra_args: <args>
#    ...
# }

packages_python: {}

# Global extra arguments for the python pip tool if no other ones are specified
# in the package config. See `packages_python` documentation before

# packages_python_extra_args:

# By default the role installs the python packages into a virtualenv in order to
# not overwrite the python packages installed by the operating system

packages_python_virtualenv: /var/lib/ansible/venv
# packages_python_virtualenv_command:
# packages_python_virtualenv_python:
packages_python_virtualenv_site_packages: yes

# Indicate if `ansible_python_interpreter` must be pointed by the role to the
# virtualenv python interpreter located in the path defined by the variable
# `packages_python_virtualenv`. This ensures that the virtualenv defined is used
# by the ansible tasks, but you can get the same functionality if you point in
# your inventory the variable `ansible_python_interpreter` to the python binary
# inside the path defined in `packages_python_virtualenv`

packages_python_set_ansible_interpreter: yes

# Dict with distribution aliases. Before comparing ansible_facts distribution
# name against the required distribution, this map will be applied.

packages_distribution_aliases:
  redhat: rhel

# List of handlers to notify when there are changes on operating system packages

packages_os_notify: []

# List of handlers to notify when there are changes on python packages

packages_python_notify: []

# List of plugins to disable

packages_disable_plugins:
  - fastestmirror

# List of plugins to enable

packages_enable_plugins: []

# Indicate packages must be loaded also from host variables. See
# `packages_os_load_from_hostvars` and `packages_python_load_from_hostvars`
# variables below for details

packages_load_from_hostvars: no

# Indicate `packages_os` must be loaded also from host variables. Any host
# variable that begins with "packages_os_*" and contains the necessary
# attributes will be loaded as an item to manage by the role. The variables must
# follow the structure detailed before for `packages_os`

packages_os_load_from_hostvars: "{{ packages_load_from_hostvars }}"

# Indicate `packages_python` must be loaded also from host variables. Any host
# variable that begins with "packages_python_*" and contains the necessary
# attributes will be loaded as an item to manage by the role. The variables must
# follow the structure detailed before for `packages_python`

packages_python_load_from_hostvars: "{{ packages_load_from_hostvars }}"

# Value to setup TMPDIR environment variable during tasks. This is may be
# necesary for python packages if you have /tmp directory protected with noexec
# flag

packages_tmp_dir: /tmp

# If you want to install python packages ansible requires python version 3.5 or
# greather, that is not available for CentOS/RHEL 6. To workaround this problem
# below you can specify the download options to setup python from sources.
# The download can be done from a path (in the control machine or the managed
# host) or from a http url.

# Path to the python source package. Can be a control machine path or host path
# (see packages_python_source_path_remote variable below). If not given, the
# http url download method will be used

#packages_python_source_path:

# Indicate if packages_python_source_path is on the control machine path (value
# no) or the managed host (value yes)

packages_python_source_path_remote: no

# Python source URL. Setup to an URL where to download python source package

packages_python_source_url: >-
  https://www.python.org/ftp/python/3.5.9/Python-3.5.9.tgz

# Timeout to download python source from url

packages_python_source_timeout: 60

# Validate or not certificates from python source url

packages_python_source_validate_certs: yes

# Path where to download python source and do compilation tasks

packages_python_source_compile_dir: /var/lib/ansible

# Mode for packages_python_source_compile_dir

packages_python_source_compile_dir_mode: 0755

# Where to install compiled python. The variable packages_python_source_version
# contains the version compiled

packages_python_source_install_dir: >-
  /var/lib/ansible/python-{{ packages_python_source_version }}
